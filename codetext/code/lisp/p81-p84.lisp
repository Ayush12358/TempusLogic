(defun p81 (graph a b)
  (do ((stack (list (list a)) (cdr stack))
       res)
      ((null stack) res)
      (dolist (edge (edges (caar stack) graph))
        (let ((n (other-node edge (caar stack))))
          (unless (member n (cdar stack))
            (if (equal n b)
                (push (reverse (car stack)) res)
                (push (cons n (car stack)) (cdr stack))))))))

(defun p82 (graph a)
  (mapcan (lambda (edge &aux (n (end-node edge)))
            (cons edge (remove (list edge) (p81 graph n a) :test #'equal)))
          (edges a graph)))

(defun p83 (graph &aux (len (length (graph-nodes graph))))
  (do ((stack (list (cons NIL NIL)))
       res)
      ((null stack) res)
      (let* ((elem (car stack)) 
             (edges (car elem))
             (nodes (cdr elem)))
        (if (= (length nodes) len)
            (pushnew edges res :test-not #'set-exclusive-or)
            (dolist (edge (set-difference (graph-edges graph) edges))
              (unless (subsetp (nodes edge) nodes)
                (push (cons (cons edge edges) (union (nodes edge) nodes)) (cdr stack))))))))

(defun s-tree-p (graph tree)
  (member tree (p83 graph)))

(defun graph-tree-p (graph)
  (s-tree-p graph graph))

(defun connected-p (graph)
  (not (null (p83 graph))))

(defun p84 (graph)
  (do ((nodes (graph-nodes graph))
       (costs (mapcar #'list (graph-nodes graph)))
       (edges (mapcar #'list (graph-nodes graph)))
       (res (make-graph))
       node)
      ((null nodes) res)
      (setf node (pred-min nodes #'cost< :key (lambda (n) (assoc n costs))))
      (setf nodes (remove node nodes :test #'equal))
      (push node (graph-nodes res))
      (when (cdr (assoc node edges))
        (push (cdr (assoc node edges)) (graph-edges res)))
      (dolist (edge (edges node graph))
        (let ((other (other-node edge node)))
          (and (member other nodes)
               (cost< (edge-weight edge) (cdr (assoc other costs)))
               (rplacd (assoc other costs) (edge-weight edge))
               (rplacd (assoc other edges) edge))))))

(defun cost< (cost1 cost2)
  (cond ((null cost1) NIL)
        ((null cost2) T)
        (T (< cost1 cost2))))

(defun pred-min (list pred &key (key identity))
  (do ((list (cdr list) (cdr list))
       (min (car list)))
      ((null list) min)
      (if (funcall pred (funcall key (car list))
                        (funcall key min))
          (setf min (car list)))))
(defun p85 (graph1 graph2)
  (and (= (length (graph-nodes graph1))
          (length (graph-nodes graph2)))
       (= (length (graph-edges graph1))
          (length (graph-edges graph2)))
       (= (length (lone-nodes  graph1))
          (length (lone-nodes  graph2)))
       (append (mapcar #'cons (lone-nodes graph1) (lone-nodes graph2))
               (car (find-isomorphisms graph1 graph2)))))

(defun find-isomorphisms (graph1 graph2 &optional (edges1 (graph-edges graph1)) (edges2 (graph-edges graph2)) res &aux found)
  (assert (= (length edges1)) (= (length edges2)))
  (cond ((null edges1)
         res)
        ((setf found (find-matches (car edges1) edges2 graph1 graph2 res))
         (mapcan (lambda (match) 
                   (find-isomorphisms graph1 graph2 (cdr edges1) 
                                      (remove (car match) edges2) 
                                      (append (cdr match) res)))
                 found))))

(defun find-matches (edge edges graph1 graph2 map &aux (start (start-node edge)) (end (end-node edge)) node)
  (cond ((setf node (assoc start map))
         (match-node end node graph1 graph2))
        ((setf node (assoc end map))
         (match-node start node graph1 graph2))
        (T 
         (mapcan (lambda (e &aux (start2 (start-node e)) (end2 (end-node e)) matches)
                   (and (= (degree start graph1)
                           (degree start2 graph2))
                        (= (degree end graph1)
                           (degree end2 graph2))
                        (push (list e (cons start start2) (cons end end2)) matches))
                   (and (= (degree start graph1)
                           (degree end2 graph2))
                        (= (degree end graph1)
                           (degree start2 graph2))
                        (push (list e (cons start end2) (cons end start2)) matches))
                   matches)
            (remove-if (lambda (e) (intersection (mapcar #'cdr map) (nodes e))) edges)))))

(defun match-node (end start graph1 graph2)
  (mapcar (lambda (e)
            (list e (cons end (remove start (nodes e)))))
    (remove-if-not (lambda (e)
                     (and (edge-of e start graph2)
                          (= (degree end graph1)
                             (degree (remove start (nodes e)) graph2))))
                   edges)))

(defun degree (node graph)
  (if (graph-directed graph)
      (out-degree node graph)
      (+ (out-degree node graph)
         (in-degree  node graph))))

(defun out-degree (node graph)
  (length (cdr (assoc node (p80a graph)))))

(defun in-degree (node graph)
  (loop for e in (graph-edges graph)
        if (eq node (end-node e))
        sum 1))

(defun sorted-nodes (graph)
  (sort (graph-nodes graph) #'> :key (lambda (node) (degree node graph))))

(defun p86 (graph &aux (res (mapcar #'list (graph-nodes graph))) (counter 0))
  (labels ((new-color () (incf counter)))
    (do ((nodes (sorted-nodes graph))
         (node (car nodes) (car nodes))
         (color (new-color) (new-color)))
        ((null nodes) res)
        (setf nodes
          (remove-if (lambda (n)
                       (and (not (or (edge node n graph) (edge n node graph)))
                            (rplacd (assoc n res) color)))
            nodes)))))

(defun p87 (graph start)
  (do* ((stack (list start) (cdr stack))
        (res stack))
       ((null stack) res)
       (dolist (n (neighbors (car stack) graph))
         (unless (member n res)
           (push n (cdr stack))))))

(defun depth-traverse-edges (graph start)
  (do* ((stack (list start) (cdr stack))
        (visited stack)
        res
        (node (car stack) (car stack)))
       ((null stack) (nreverse res))
       (dolist (n (neighbors node graph))
         (unless (member n visited)
           (push res (cons node n))
           (push n (cdr stack))))))

(defun p88 (graph)
  (do ((nodes (sorted-nodes graph))
       res)
      ((null nodes) res)
      (dolist (n (p87 graph (car nodes)))
         (setf nodes (remove n nodes))
         (push n res))))

(defun p89 (graph &aux (colors (mapcar #'list (graph-nodes graph))))
  (labels ((next (color) (- 3 color)))
    (dolist (comp (p88 graph))
      (rplacd (assoc (car comp) colors) 1)
      (dolist (e (depth-traverse-edges graph (car comp)))
        (assert (and (cdr (assoc (start-node e) colors))
                     (not (cdr (assoc (end-node e) colors)))))
        (rplacd (assoc (end-node e) colors)
          (next (cdr (assoc (start-node e) colors))))
        (dolist (edge (edges (end-node e) graph))
          (if (eq (assoc (start-node edge) colors)
                  (assoc (end-node   edge) colors))
              (return-from 'p89))))))
  (let ((res (list NIL)))
    (dolist (coloring colors res)
      (case (cdr coloring)
        (1 (push (car coloring) (car res)))
        (2 (push (car coloring) (cdr res)))
        (T (return-from 'p89))))))
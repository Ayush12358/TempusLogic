(defun p54 (tree)
  (or (null tree)
      (and (listp tree)
           (= (length tree) 2)
           (p54 (second tree))
           (p54 (third tree)))))

(defun p55 (n)
  (when (> n 0)
    (reduce #'union (mapcar #'gen-cbal-trees (p55 (1- n))))))

(defun gen-cbal-trees (tree &aux (sym 'X))
  (if (null tree)
      (list sym NIL NIL)
      (let ((n1 (nodes (second tree)))
            (n2 (nodes (third tree))))
        (cond ((= n1 n2)
               (union (mapcar (lambda (tr) (list sym (second tree) tr))
                        (gen-cbal-trees (third tree)))
                      (mapcar (lambda (tr) (list sym tr (third tree)))
                        (gen-cbal-trees (second tree)))))
              ((< n1 n2)
               (mapcar (lambda (tr) (list sym tr (third tree)))
                 (gen-cbal-trees (second tree))))
              (T
               (mapcar (lambda (tr) (list sym (second tree) tr))
                 (gen-cbal-trees (third tree))))))))

(defun cbal-tree-p (tree)
  (or (null tree)
      (and (p54 tree)
           (<= (abs (- (nodes (second tree))
                       (nodes (third tree))))
               1)
           (cbal-tree-p (second tree))
           (cbal-tree-p (third tree)))))

(defun nodes (tree)
  (if (null tree)
      0
      (+ 1 (nodes (second tree)) (nodes (third tree)))))

(defun p56 (tree)
  (or (null tree)
      (mirror-p (second tree) (third tree))))

(defun mirror-p (tree1 tree2)
  (if (null tree1)
      (null tree2)
      (and (mirror-p (second tree1) (third tree2))
           (mirror-p (third tree1) (second tree2)))))

(defun p57 (list)
  (do ((tree NIL (bst-insert (pop list) tree)))
      ((null list) tree)))

(defun bst-insert (item tree)
  (cond ((null tree) (list item NIL NIL))
        ((= item (first tree)) tree)
        ((< item (first tree))
         (list (first tree)
               (bst-insert item (second tree))
               (third tree)))
        (T
         (list (first tree)
               (second tree)
               (bst-insert item (third tree))))))

(defun test-symmetric (list)
  (p56 (p57 list)))

(defun p58 (n)
  (remove-if-not #'p56 (p55 n)))

(defun sym-cbal-tree-count (n)
  (length (p58 n)))

(defun p59 (tree)
  (or (null tree)
      (and (p54 tree)
           (<= (abs (- (height (second tree))
                       (height (third tree))))
               1)
           (p59 (second tree))
           (p59 (third tree)))))

(defun hbal-trees (n)
  (when (> n 0)
    (reduce #'union (mapcar #'gen-hbal-trees (hbal-trees (1- n))))))

(defun gen-hbal-trees (tree &aux (sym 'X))
  (labels ((gen-right (tree1)
             (mapcar (lambda (tr) (list sym (second tree1) tr))
               (gen-hbal-trees (third tree1))))
           (gen-left (tree1)
             (mapcar (lambda (tr) (list sym tr (third tree1)))
               (gen-hbal-trees (second tree1)))))
    (if (null tree)
        (list sym NIL NIL)
        (let ((h1 (height (second tree)))
              (h2 (height (third tree))))
          (cond ((<= (abs (- h1 h2)) 1)
                 (union (gen-left tree) (gen-right tree)))
                ((< h1 h2)
                 (gen-left tree))
                (T (gen-right tree)))))))

(defun height (tree)
  (if (null tree)
      0
      (1+ (max (height (second tree))
               (height (third tree))))))

(defun p60a (height)
  (if (= height 0)
      0
      (+ 1 (p60a (1- height))
           (p60a (- height 2)))))

(defun p60b (nodes)
  (if (= nodes 0)
      0
      (do ((n (ceiling (1- nodes) 2) (1+ n))
           (max 0))
          ((= n nodes) (1+ max))
          (let ((h1 (p60b n))
                (h2 (p60b (- nodes n))))
            (when (<= (abs (- h1 h2)) 1)
              (setf max (max max h1 h2)))))))

(defun p60c (nodes)
  (if (= nodes 0)
      0
      (1+ (max (p60c (floor (1- nodes) 2))
               (p60c (ceiling (1- nodes) 2))))))

(defun hbal-tree-nodes (nodes)
  (remove-if-not (lambda (tree)
                   (= (nodes tree) nodes))
    (reduce #'union (mapcar #'hbal-trees (p22 (p60c nodes) (p60b nodes))))))
